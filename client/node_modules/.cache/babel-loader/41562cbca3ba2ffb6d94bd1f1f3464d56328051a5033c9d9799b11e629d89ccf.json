{"ast":null,"code":"function createParser(onParse) {\n  var isFirstChunk;\n  var buffer;\n  var startingPosition;\n  var startingFieldLength;\n  var eventId;\n  var eventName;\n  var data;\n  reset();\n  return {\n    feed: feed,\n    reset: reset\n  };\n  function reset() {\n    isFirstChunk = true;\n    buffer = \"\";\n    startingPosition = 0;\n    startingFieldLength = -1;\n    eventId = void 0;\n    eventName = void 0;\n    data = \"\";\n  }\n  function feed(chunk) {\n    buffer = buffer ? buffer + chunk : chunk;\n    if (isFirstChunk && hasBom(buffer)) {\n      buffer = buffer.slice(BOM.length);\n    }\n    isFirstChunk = false;\n    var length = buffer.length;\n    var position = 0;\n    var discardTrailingNewline = false;\n    while (position < length) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === \"\\n\") {\n          ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      var lineLength = -1;\n      var fieldLength = startingFieldLength;\n      var character = void 0;\n      for (var index = startingPosition; lineLength < 0 && index < length; ++index) {\n        character = buffer[index];\n        if (character === \":\" && fieldLength < 0) {\n          fieldLength = index - position;\n        } else if (character === \"\\r\") {\n          discardTrailingNewline = true;\n          lineLength = index - position;\n        } else if (character === \"\\n\") {\n          lineLength = index - position;\n        }\n      }\n      if (lineLength < 0) {\n        startingPosition = length - position;\n        startingFieldLength = fieldLength;\n        break;\n      } else {\n        startingPosition = 0;\n        startingFieldLength = -1;\n      }\n      parseEventStreamLine(buffer, position, fieldLength, lineLength);\n      position += lineLength + 1;\n    }\n    if (position === length) {\n      buffer = \"\";\n    } else if (position > 0) {\n      buffer = buffer.slice(position);\n    }\n  }\n  function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {\n    if (lineLength === 0) {\n      if (data.length > 0) {\n        onParse({\n          type: \"event\",\n          id: eventId,\n          event: eventName || void 0,\n          data: data.slice(0, -1)\n          // remove trailing newline\n        });\n\n        data = \"\";\n        eventId = void 0;\n      }\n      eventName = void 0;\n      return;\n    }\n    var noValue = fieldLength < 0;\n    var field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));\n    var step = 0;\n    if (noValue) {\n      step = lineLength;\n    } else if (lineBuffer[index + fieldLength + 1] === \" \") {\n      step = fieldLength + 2;\n    } else {\n      step = fieldLength + 1;\n    }\n    var position = index + step;\n    var valueLength = lineLength - step;\n    var value = lineBuffer.slice(position, position + valueLength).toString();\n    if (field === \"data\") {\n      data += value ? \"\".concat(value, \"\\n\") : \"\\n\";\n    } else if (field === \"event\") {\n      eventName = value;\n    } else if (field === \"id\" && !value.includes(\"\\0\")) {\n      eventId = value;\n    } else if (field === \"retry\") {\n      var retry = parseInt(value, 10);\n      if (!Number.isNaN(retry)) {\n        onParse({\n          type: \"reconnect-interval\",\n          value: retry\n        });\n      }\n    }\n  }\n}\nvar BOM = [239, 187, 191];\nfunction hasBom(buffer) {\n  return BOM.every(function (charCode, index) {\n    return buffer.charCodeAt(index) === charCode;\n  });\n}\nexport { createParser };","map":{"version":3,"names":["createParser","onParse","isFirstChunk","buffer","startingPosition","startingFieldLength","eventId","eventName","data","reset","feed","chunk","hasBom","slice","BOM","length","position","discardTrailingNewline","lineLength","fieldLength","character","index","parseEventStreamLine","lineBuffer","type","id","event","noValue","field","step","valueLength","value","toString","concat","includes","retry","parseInt","Number","isNaN","every","charCode","charCodeAt"],"sources":["/Users/ayzo/cs178/project/showup/showup/showup/node_modules/eventsource-parser/src/parse.ts"],"sourcesContent":["/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n *\n * Based on code from the {@link https://github.com/EventSource/eventsource | EventSource module},\n * which is licensed under the MIT license. And copyrighted the EventSource GitHub organisation.\n */\nimport type {EventSourceParseCallback, EventSourceParser} from './types.js'\n\n/**\n * Creates a new EventSource parser.\n *\n * @param onParse - Callback to invoke when a new event is parsed, or a new reconnection interval\n *                  has been sent from the server\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(onParse: EventSourceParseCallback): EventSourceParser {\n  // Processing state\n  let isFirstChunk: boolean\n  let buffer: string\n  let startingPosition: number\n  let startingFieldLength: number\n\n  // Event state\n  let eventId: string | undefined\n  let eventName: string | undefined\n  let data: string\n\n  reset()\n  return {feed, reset}\n\n  function reset(): void {\n    isFirstChunk = true\n    buffer = ''\n    startingPosition = 0\n    startingFieldLength = -1\n\n    eventId = undefined\n    eventName = undefined\n    data = ''\n  }\n\n  function feed(chunk: string): void {\n    buffer = buffer ? buffer + chunk : chunk\n\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n    // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n    // always decoded as UTF8 as per the specification.\n    if (isFirstChunk && hasBom(buffer)) {\n      buffer = buffer.slice(BOM.length)\n    }\n\n    isFirstChunk = false\n\n    // Set up chunk-specific processing state\n    const length = buffer.length\n    let position = 0\n    let discardTrailingNewline = false\n\n    // Read the current buffer byte by byte\n    while (position < length) {\n      // EventSource allows for carriage return + line feed, which means we\n      // need to ignore a linefeed character if the previous character was a\n      // carriage return\n      // @todo refactor to reduce nesting, consider checking previous byte?\n      // @todo but consider multiple chunks etc\n      if (discardTrailingNewline) {\n        if (buffer[position] === '\\n') {\n          ++position\n        }\n        discardTrailingNewline = false\n      }\n\n      let lineLength = -1\n      let fieldLength = startingFieldLength\n      let character: string\n\n      for (let index = startingPosition; lineLength < 0 && index < length; ++index) {\n        character = buffer[index]\n        if (character === ':' && fieldLength < 0) {\n          fieldLength = index - position\n        } else if (character === '\\r') {\n          discardTrailingNewline = true\n          lineLength = index - position\n        } else if (character === '\\n') {\n          lineLength = index - position\n        }\n      }\n\n      if (lineLength < 0) {\n        startingPosition = length - position\n        startingFieldLength = fieldLength\n        break\n      } else {\n        startingPosition = 0\n        startingFieldLength = -1\n      }\n\n      parseEventStreamLine(buffer, position, fieldLength, lineLength)\n\n      position += lineLength + 1\n    }\n\n    if (position === length) {\n      // If we consumed the entire buffer to read the event, reset the buffer\n      buffer = ''\n    } else if (position > 0) {\n      // If there are bytes left to process, set the buffer to the unprocessed\n      // portion of the buffer only\n      buffer = buffer.slice(position)\n    }\n  }\n\n  function parseEventStreamLine(\n    lineBuffer: string,\n    index: number,\n    fieldLength: number,\n    lineLength: number\n  ) {\n    if (lineLength === 0) {\n      // We reached the last line of this event\n      if (data.length > 0) {\n        onParse({\n          type: 'event',\n          id: eventId,\n          event: eventName || undefined,\n          data: data.slice(0, -1), // remove trailing newline\n        })\n\n        data = ''\n        eventId = undefined\n      }\n      eventName = undefined\n      return\n    }\n\n    const noValue = fieldLength < 0\n    const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength))\n    let step = 0\n\n    if (noValue) {\n      step = lineLength\n    } else if (lineBuffer[index + fieldLength + 1] === ' ') {\n      step = fieldLength + 2\n    } else {\n      step = fieldLength + 1\n    }\n\n    const position = index + step\n    const valueLength = lineLength - step\n    const value = lineBuffer.slice(position, position + valueLength).toString()\n\n    if (field === 'data') {\n      data += value ? `${value}\\n` : '\\n'\n    } else if (field === 'event') {\n      eventName = value\n    } else if (field === 'id' && !value.includes('\\u0000')) {\n      eventId = value\n    } else if (field === 'retry') {\n      const retry = parseInt(value, 10)\n      if (!Number.isNaN(retry)) {\n        onParse({type: 'reconnect-interval', value: retry})\n      }\n    }\n  }\n}\n\nconst BOM = [239, 187, 191]\n\nfunction hasBom(buffer: string) {\n  return BOM.every((charCode: number, index: number) => buffer.charCodeAt(index) === charCode)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}